---
title: Signal Lifecycle
description: What happens after your strategy fires a signal.
---

1. **Strategy emits `Signal`** – Typically from `on_tick` or `on_candle`. Use the provided `SignalBuilder` helpers to keep payloads consistent.
2. **Execution Engine** – Receives the signal, enriches it with portfolio context, and chooses an execution hint (VWAP, PeggedBest, Sniper, etc.).
3. **Risk Filters** – Guardrails (max position size, participation caps) run before any order hits the wire.
4. **Order Routing** – The engine translates the validated intent into `OrderRequest`s and hands them to the configured `ExecutionClient`.
5. **Fill Feedback** – Executions stream back through the event bus; the strategy can react in `on_fill`, and the portfolio updates realized PnL.

```text
Signal -> Execution -> Risk -> Orders -> Exchange -> Fills -> Portfolio
```

Keep the signal payload focused on _intent_ (e.g., “go long BTCUSDT, size 0.5”). Pricing tactics, throttling, and compliance rules live downstream so they can be audited centrally.

### Multi-Leg Safety (New)

Signals now support two extra fields that make cross-venue pairs safer:

- `group_id`: assign the same UUID to all legs of a trade, or let the runtime infer it when you call `Signal::with_group`. The router tags every child order with this ID so fills, logs, and panic handling remain linked even if the legs live on different connectors.
- `panic_behavior`: override the global panic-close policy per signal by calling `Signal::with_panic_behavior`. Use `SignalPanicBehavior::AggressiveLimit { offset_bps: 25 }` when you want the orchestrator to try an IOC limit 25 bps beyond the last mark before falling back to a market exit, or `SignalPanicBehavior::Market` when latency matters more than price.

Pairs, basis trades, or any strategy that spans venues should set these explicitly so the router can unwind consistently if only one leg fills.

```rust
let group = Uuid::new_v4();
let binance = ExchangeId::from("binance_perp");
let bybit = ExchangeId::from("bybit_linear");
let entry = Signal::new(
    Symbol::from_code(binance, "BTCUSDT"),
    SignalKind::EnterLong,
    0.05,
)
.with_group(group)
.with_panic_behavior(SignalPanicBehavior::AggressiveLimit {
    offset_bps: Decimal::from(20u32),
});
let hedge = Signal::new(
    Symbol::from_code(bybit, "BTCUSDT"),
    SignalKind::EnterShort,
    0.05,
)
.with_group(group)
.with_panic_behavior(SignalPanicBehavior::Market);
ctx.publish(entry);
ctx.publish(hedge);
```

In the example above the orchestrator keeps both legs linked via `group_id`, yet each leg gets a tailored unwind policy (limit for Binance, market for Bybit) if only one side fills.

## PeggedBest Execution Hint

Attach `ExecutionHint::PeggedBest` to a signal when you want the execution layer to rest passively at the top of book and automatically “chase” the quote. The orchestrator now keeps a single child order working on the exchange and issues native amendments instead of cancel/re-place cycles, which preserves queue position and dramatically reduces API weight consumption.

Tuning knobs:

- `offset_bps` – how far inside/outside the top of book the pegged order should anchor.
- `clip_size` – optional maximum displayed size per child (falls back to the full parent quantity).
- `refresh_secs` – minimum time between refreshes; use this with volatile markets to avoid thrashing.
- `min_chase_distance` – the newest knob; it sets the minimum price delta (in absolute quote terms) before a chase occurs, providing a guardrail against micro-ticks that would otherwise generate excessive amend calls.

Because the runtime amends the resting child order in place, fills stream back against a single order ID and state is persisted through restarts. Set `min_chase_distance` according to your tick size and exchange rate limits to balance spread capture against API pressure.

## TrailingStop Execution Hint

`ExecutionHint::TrailingStop` gives strategies a venue-agnostic trailing-stop primitive. Provide an `activation_price` and a fractional `callback_rate`. Once ticks trade through the activation level the orchestrator records the highest price seen, refreshing that watermark as the market rallies. If price ever falls below `highest * (1 - callback_rate)`, the algorithm fires a market sell that flattens the configured quantity.

This logic runs entirely inside the execution layer, so it inherits the same persistence/recovery guarantees as TWAP/VWAP. Use it to guard profits without wiring exchange-specific trailing orders or polluting strategy code with ticker state.
