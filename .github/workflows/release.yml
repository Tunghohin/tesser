name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release Level'
        required: true
        type: choice
        options:
          # Standard semantic version bumps
          - patch
          - minor
          - major
          # Pre-release bumps
          - alpha
          - beta
          - rc
          # Promote pre-release to official (e.g., 1.0.0-rc.1 -> 1.0.0)
          - release
        default: patch
      rerun_release:
        description: 'Reuse an existing tag (skip version bump)'
        required: true
        type: boolean
        default: false
      existing_tag:
        description: 'Existing tag (required when rerun_release=true)'
        required: false
        type: string

env:
  CARGO_TERM_COLOR: always
  PACKAGE_NAME: tesser-cli

jobs:
  # 1. Verification Phase
  check-dry-run:
    name: Verify and Dry Run
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event.inputs.rerun_release != 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install cargo-release
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-release

      - name: Check cargo publish (Dry Run)
        # 'cargo release' handles keywords like 'alpha', 'beta' natively
        run: cargo release ${{ github.event.inputs.version }} --dry-run --no-push --no-tag --no-publish

      - name: Check compilation
        run: cargo check --release

  # 2. State Mutation Phase
  tag-and-push:
    name: Bump Version and Tag
    if: github.event.inputs.rerun_release != 'true'
    needs: check-dry-run
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      tag_name: ${{ steps.tag.outputs.tag_name }}
      is_prerelease: ${{ steps.tag.outputs.is_prerelease }}
      changelog: ${{ steps.changelog.outputs.body }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install tools
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-release, git-cliff

      - name: Configure Git
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Bump version and commit
        # --no-tag: We create the tag manually to ensure it is unique
        # --no-confirm: Crucial for CI automation
        run: cargo release ${{ github.event.inputs.version }} --execute --no-publish --no-push --no-confirm --no-tag

      - name: Create Single Tag and Detect Prerelease
        id: tag
        shell: bash
        run: |
          # 1. Get exact version from Cargo metadata
          VERSION=$(cargo metadata --format-version 1 --no-deps | jq -r ".packages[] | select(.name == \"${{ env.PACKAGE_NAME }}\") | .version")
          
          if [ -z "$VERSION" ]; then
            echo "::error::Could not determine version!"
            exit 1
          fi
          
          TAG="v$VERSION"
          
          # 2. Manually create tag
          git tag -a "$TAG" -m "Release $TAG"
          
          # 3. Detect if this is a pre-release (contains a hyphen, e.g., 0.2.0-alpha.1)
          if [[ "$VERSION" == *"-"* ]]; then
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
            echo "Detected PRE-RELEASE version."
          else
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
            echo "Detected STABLE version."
          fi
          
          echo "tag_name=$TAG" >> "$GITHUB_OUTPUT"

      - name: Generate changelog
        id: changelog
        run: |
          git-cliff --latest --strip all > RELEASE_NOTES.md
          {
            echo 'body<<EOF'
            cat RELEASE_NOTES.md
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Push changes
        run: git push origin HEAD:refs/heads/main --tags

  reuse-tag:
    name: Reuse Existing Tag
    if: github.event.inputs.rerun_release == 'true'
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.emit.outputs.tag_name }}
      is_prerelease: ${{ steps.emit.outputs.is_prerelease }}
      changelog: ${{ steps.changelog.outputs.body }}
    steps:
      - name: Validate inputs
        run: |
          if [ -z "${{ github.event.inputs.existing_tag }}" ]; then
            echo "::error::existing_tag is required when rerun_release=true"
            exit 1
          fi
      - name: Checkout existing tag
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.inputs.existing_tag }}
      - name: Emit tag metadata
        id: emit
        run: |
          TAG="${{ github.event.inputs.existing_tag }}"
          VERSION="${TAG#v}"
          if [[ "$VERSION" == "$TAG" ]]; then
            echo "::error::existing_tag must begin with 'v'"
            exit 1
          fi
          if [[ "$VERSION" == *"-"* ]]; then
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
          else
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
          fi
          echo "tag_name=$TAG" >> "$GITHUB_OUTPUT"
      - name: Regenerate changelog
        id: changelog
        run: |
          git-cliff --latest --strip all > RELEASE_NOTES.md
          {
            echo 'body<<EOF'
            cat RELEASE_NOTES.md
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

  # 3. Build Phase
  build-artifacts:
    name: Build Artifacts
    needs:
      - tag-and-push
      - reuse-tag
    runs-on: ${{ matrix.os }}
    env:
      RELEASE_TAG: ${{ needs.tag-and-push.outputs.tag_name || needs.reuse-tag.outputs.tag_name }}
    strategy:
      fail-fast: true
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            archive: tar.gz
          - os: macos-latest
            target: x86_64-apple-darwin
            archive: tar.gz
          - os: macos-latest
            target: aarch64-apple-darwin
            archive: tar.gz
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            archive: zip
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}

      - name: Install musl-tools
        if: matrix.target == 'x86_64-unknown-linux-musl'
        run: sudo apt-get update && sudo apt-get install -y musl-tools

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Build binary
        run: cargo build --package ${{ env.PACKAGE_NAME }} --release --target ${{ matrix.target }}

      - name: Package binary
        shell: bash
        run: |
          set -euo pipefail
          
          CLI_NAME="${{ env.PACKAGE_NAME }}"
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            CLI_NAME="${{ env.PACKAGE_NAME }}.exe"
          fi
          
          ARTIFACT_NAME="${{ env.PACKAGE_NAME }}-${{ env.RELEASE_TAG }}-${{ matrix.target }}"
          mkdir -p "$ARTIFACT_NAME"
          
          cp "target/${{ matrix.target }}/release/${CLI_NAME}" "$ARTIFACT_NAME/"
          
          if [[ "${{ matrix.archive }}" == "zip" ]]; then
            ARCHIVE_PATH="${ARTIFACT_NAME}.zip"
            7z a "$ARCHIVE_PATH" "./$ARTIFACT_NAME/*" >/dev/null
          else
            ARCHIVE_PATH="${ARTIFACT_NAME}.tar.gz"
            tar -czf "$ARCHIVE_PATH" -C "$ARTIFACT_NAME" .
          fi
          
          echo "ASSET_PATH=$ARCHIVE_PATH" >> "$GITHUB_ENV"

      - name: Upload intermediate artifact
        uses: actions/upload-artifact@v4
        with:
          name: bin-${{ matrix.target }}
          path: ${{ env.ASSET_PATH }}
          retention-days: 1

  # 4. Publication Phase
  publish-final:
    name: Publish to Registry and GitHub
    needs:
      - tag-and-push
      - reuse-tag
      - build-artifacts
    runs-on: ubuntu-latest
    env:
      RELEASE_TAG: ${{ needs.tag-and-push.outputs.tag_name || needs.reuse-tag.outputs.tag_name }}
      RELEASE_NOTES: ${{ needs.tag-and-push.outputs.changelog || needs.reuse-tag.outputs.changelog }}
      RELEASE_IS_PRERELEASE: ${{ needs.tag-and-push.outputs.is_prerelease || needs.reuse-tag.outputs.is_prerelease }}
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Download built artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: bin-*
          path: dist
          merge-multiple: true

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_TAG }}
          body: ${{ env.RELEASE_NOTES }}
          files: dist/*
          draft: false
          # Automatically check the "Prerelease" box if it is alpha/beta/rc
          prerelease: ${{ env.RELEASE_IS_PRERELEASE }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute publish order
        id: publish_order
        run: |
          ORDER=$(python .github/scripts/compute_publish_order.py)
          {
            echo 'crates<<EOF'
            echo "$ORDER"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Publish to Crates.io
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CRATES_IO_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${CARGO_REGISTRY_TOKEN:-}" ]; then
            echo "::error::CRATES_IO_TOKEN secret is not configured."
            exit 1
          fi
          while IFS= read -r crate; do
            [ -z "$crate" ] && continue
            echo "::group::Publishing $crate"
            version=$(cargo pkgid -p "$crate" | sed 's/.*://')
            if ! cargo publish -p "$crate"; then
              if curl -sSf "https://crates.io/api/v1/crates/${crate}/${version}" >/dev/null; then
                echo "::warning::${crate} v${version} already published, skipping"
              else
                echo "::error::Failed to publish ${crate} v${version}"
                exit 1
              fi
            fi
            echo "::endgroup::"
            echo "Sleeping 2 minutes to satisfy crates.io rate limits..."
            sleep 120
          done <<< "${{ steps.publish_order.outputs.crates }}"
